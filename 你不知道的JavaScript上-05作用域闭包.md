# 作用域闭包

当函数可以==记住并访问所在的词法作用域时==，就产生了闭包，即使函数是在当前词法作用域外执行。

```js
function foo() {
    var a = 2
    function bar() {
        console.log(a)
    }
    return bar
}
var baz = foo()

baz()   //2
```

- 函数bar()的词法作用域能够访问foo()的内部作用域。
- 然后将bar()函数本身当作一个值类型进行传递。(本例将bar函数对象本身当作返回值)
- foo()执行后，其返回值(bar函数本身)赋值给变量baz，并调用baz()
- 实际上只是通过不同的标识符引用调用了内部的函数bar()
- bar()在自己定义的词法作用域以外的地方执行。
- 在foo()执行后，通常期待foo()的整个内部作用域都被销毁(引擎垃圾回收器将函数执行完毕就会被销毁释放内存),由于看上去
foo()的内容不会再被使用，所以很自然地考虑对其进行回收。
- 闭包的`神奇`之处正是可以阻止这件事情的发生。事实上内部作用于依然存在，因此没有被回收，而是bar()函数本身正在使用这个内部作用域
- 拜bar()所声明的位置所赐，它拥有涵盖foo()内部作用域的闭包，使得该作用域一直存活，以供bar()在之后任何时间进行引用
- bar()依然持有对该作用域的引用，而这个引用就叫做闭包。

**无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包**

```js
function foo() {
    var a = 2
    function baz() {
        console.log(a)
    }
    bar(baz)
}

function bar(fn) {
    fn()
}
foo()
```
将内部函数baz传递给bar，当调用这个内部函数时(现在叫作fn)，它涵盖的foo()内部作用域的闭包就可ui观察到了，

**无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。**
```js
function wait(message) {
  setTimeout(function timer() {
        console.log(message)
  },1000)
}
wait("hello,closure!")
```
- 将一个内部函数，传递个setTimeout()函数的第一个参数，timer具有涵盖wait()作用域的闭包，因此还保存有
对变量message的引用。
- wait()执行1000ms后，它的内部作用域并不会消失，timer函数依然保存有wait()作用域的闭包
- 在引擎内部，内置的工具函数setTimeout(..)持有对一个参数的引用，这个参数也许叫作fn或者func，或者其他类似的名字。引擎会调用这个函数，在例子中就是内部的timer函数，而词法作用域在这个过程中保持完整。

**在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！**
## 5.6小结
**闭包就好像从JavaScript中分离出来的一个充满神秘色彩的未开化世界，只有最勇敢的人才能够到达那里。但实际上它只是一个普通且明显的事实，那就是我们在词法作用域的环境下写代码，而其中的函数也是值，可以随意传来传去。**

**当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。**

**如果没能认出闭包，也不了解它的工作原理，在使用它的过程中就很容易犯错，比如在循环中。但同时闭包也是一个非常强大的工具，可以用多种形式来实现模块等模式。**

**模块有两个主要特征：（1）为创建内部作用域而调用了一个包装函数；（2）包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。**

