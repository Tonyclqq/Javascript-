# 作用域是什么？

## 1.1、编译原理

传统的编译语言流程中，程序中的一段源代码在执行之前会经历三个步骤：

1. 分词/词法分析
   1. 这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元（token）。例如，考虑程序var a = 2;。这段程序通常会被分解成为下面这些词法单元：var、a、=、2 、;。空格是否会被当作词法单元，取决于空格在这门语言中是否具有意义。
2. 解析/语法解析
   1. 这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree, AST）。var a = 2；的抽象语法树中可能会有一个叫作VariableDeclaration的顶级节点，接下来是一个叫作Identifier（它的值是a）的子节点，以及一个叫作AssignmentExpression的子节点。AssignmentExpression节点有一个叫作NumericLiteral（它的值是2）的子节点。
3. 代码生成
   1. 将AST转换为可执行代码的过程被称为代码生成。这个过程与语言、目标平台等息息相关。抛开具体细节，简单来说就是有某种方法可以将var a = 2；的AST转化为一组机器指令，用来创建一个叫作a的变量（包括分配内存等），并将一个值储存在a中。

对于**`JavaScript来说`**：大部分编译发生在代码执行前的几微秒的时间内。简单的说，任何`JavaScript`代码片段在执行前都要进行编译

## 1.2、理解作用域

要想理解作用域先要介绍三个人物：

1. ==引擎==：从头到尾负责整个JavaScript程序的编译及执行过程。
2. ==编译器==:负责语法分析及代码生成等脏活累活（看1.1讲解）
3. ==作用域==:负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

------

为了能够完全理解JavaScript的工作原理，你需要开始像引擎（和它的朋友们）一样思考，从它们的角度提出问题，并从它们的角度回答这些问题。

当看到`var a = 2 时，`，直接分析代码的工作原理

- 编译器首先会登场：遇到var a ，==编译器==会询问==作用域==是否有一个该名称的变量存在于同一个作用域集合中？(先问当前作用域，a这个变量在你这里不在)，如果是，编译器会忽略该声明，继续进行编译；否则会在当前作用域的集合中声明一个新的变量，并命名为`a`
- 编译器会为引擎生成所需要的代码，==被用来处理a = 2==这个操作。引擎先问作用域，当前作用于集合是否存在一个叫做a的变量。如果是，引擎使用这个变量，如果否，引擎会继续查找该变量
- 总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。**`编译器询问作用域的目的是：是否要声明变量`**、**`询问作用域的目的是：如果找到就会对它赋值。`**

### 1.2.1编译器有话说-LHS&RHS

编译器在编译过程的第二步中生成了代码，引擎执行它时，会通过查找变量a来判断它是否已声明过。查找的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查找结果。引擎会为变量a进行==LHS查询==，另外一个查找的类型叫做==RHS==!

换句话说，当变量出现在==赋dui值操作的左侧时进行LHS查询==，出现在==右侧时进行RHS查询==。

考虑以下代码

```js
console.log(a)
//对a的引用是一个RHS引用，因为这里a并没有赋予任何值。相应地，需要查找并取得a的值，这样才能将值传递给console.log(..)
```

对**`LHS`**&**`RHS`**的理解:

不要将其视为左侧或右侧分配，而应将其视为将值存储到内存中并在以后检索它。

例如：

当您输入`b`chrome开发者控制台时，它将启动`RHS`查找（检索的值`b`），如果未找到该值，则抛出`ReferenceError`。

相反，`b = 2`在chrome开发人员控制台中键入时，它会开始`LHS`查找，并且如果在嵌套作用域中未找到b，则JS编译器会在全局作用域中声明它（取决于您是否在其中运行代码`strict mode`）。

考虑以下代码

```js
function foo(a) {
    console.log( a + b)
}

foo( 2 );
```



### 1.2.2 引擎与作用域的对话

```js
function f00(a){
    console.log(a);//2
}
foo(2)
//上面的代码要先要编译为这样
var foo;//函数的声明
var a
function foo(a){console.log(a);}
foo(2)//函数的调用
```

让我们把上面这段代码的处理过程想象成一段对话，这段对话可能是下面这样的。

引擎：我说作用域，我需要为foo进行RHS引用。你见过它吗？

作用域：别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。(引擎要使用这个foo函数)

引擎：哥们太够意思了！好吧，我来执行一下foo。

引擎：作用域，还有个事儿。我需要为a进行LHS引用，这个你见过吗？(==将 =2存储到内存中,赋值给变量a==)

作用域：这个也见过，编译器最近把它声名为foo的一个形式参数了，拿去吧。

引擎：大恩不言谢，你总是这么棒。现在我要把2赋值给a。

引擎：哥们，不好意思又来打扰你。我要为console进行RHS引用，你见过它吗？(==要检索这个console.log()这个函数==)

作用域：咱俩谁跟谁啊，再说我就是干这个。这个我也有，console是个内置对象。给你。

引擎：么么哒。我得看看这里面是不是有log(..)。太好了，找到了，是一个函数。

引擎：哥们，能帮我再找一下对a的RHS引用吗？虽然我记得它，但想再确认一次。(==检索这个变量a==)

作用域：放心吧，这个变量没有变动过，拿走，不谢。

引擎：真棒。我来把a的值，也就是2，传递进log(..)

## 1.3作用域嵌套

通常：作用域是根据`名称`查找`变量`的一套法则

当一个`块或函数`嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。

遍历嵌套`作用域链`的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。

**把作用域链比喻成一个建筑**

![作用域链图](./img/作用域链图.jfif)

第一层代表当前作用域；顶层代表全局作用域；

LHS和RHS引用都会在当前楼层进行查找，如果没有找到，就会坐电梯前往上一层楼，如果还是没有找到就继续向上，以此类推。一旦抵达顶层（全局作用域），可能找到了你所需的变量，也可能没找到，但无论如何查找过程都将停止。

### 1.4异常   ReferenceError   &typeError

**`ReferenceError`**:如果RHS查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出`ReferenceError`异常。

**`typeError`**:如果RHS查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用，或者引用null或undefined类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作`TypeError`。

### 1.5总结:

JS执行过程

1. 编译器先负责语法分析及代码生成，在此期间，==编译器==会询问==作用域==是否有一个该名称的变量存在于同一个作用域集合中？(先问当前作用域，a这个变量在你这里不在)，如果是，编译器会忽略该声明，继续进行编译；否则会在当前作用域的集合中声明一个新的变量，并命名为`a`
2. 引擎：开始执行编译器生成的代码，期间会采用LHS和RHS的方式去问当前作用域，如果没有，会通过作用域链知道顶层去查找，如果查找不到就会报错`ReferenceError & typeError`。如果查找到就执行代码。

作用域究竟是什么！：

*作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么就会使用LHS查询；如果目的是获取变量的值，就会使用RHS查询。*