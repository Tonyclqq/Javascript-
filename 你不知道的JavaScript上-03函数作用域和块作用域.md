# 函数作用域和块作用域

*作用域包含了一系列的“气泡”，每一个都可以作为容器，其中包含了标识符（变量、函数）的定义。这些气泡互相嵌套并且整齐地排列成蜂窝型，排列的结构是在写代码时定义的。*

## 3.1、函数中的作用域

```js
function foo(a){
    bar b = 3;
    function bar() {
        //...
    }
    //更多代码
    var c = 4 ;
}
```

这个代码片段中，

foo()的作用域气泡中包含了标识符a、b、c、bar。

==无论标识符声明出现在作用域中的何处，这个标识符所代表的变量或函数都将附属于所处作用域的气泡==

bar()拥有自己的作用于气泡

全局作用域拥有自己的作用域气泡，并且只包含了一个标识符:foo

由于标识符 a、b、c、bar 都附属于foo()的作用域气泡，因此无法从foo()函数的外部对它们进行访问。也就是说，这些标识符无法从全局作用域进行访问，因此下面的代码会导致RefreenceError错误

**==函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。这种设计方案是非常有用的，能充分利用JavaScript变量可以根据需要改变值类型的“动态”特性。==**

## 3.2、隐藏内部实现

**什么叫隐藏内部实现呢？**

对函数的传统认知是先声明一个函数，然后在向里面添加代码，反过来想：从所写的代码中挑选出一个任意的片段，然后用函数声明对它进行包装，实际上就是把这些代码“隐藏”起来了。也就是说这段代码中的任何声明（变量或函数）都将绑定在这个新创建的包装函数的作用域中，而不是先前所在的作用域中。

**为什么`“隐藏”`变量和函数是一个有用的技术？**

这种基于作用域的隐藏方法。它们大都是从最小特权原则中引申出来的，也叫最小授权或最小暴露原则。这个原则是指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的API设计。

**全局作用域声明函数的和变量的坏处！**

不能最小限度的暴露必要位置，会暴露过多的函数和变量

**规避同名标识符的冲突**

“隐藏”作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突，两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致变量的值被意外覆盖。

## 3.3、函数作用域

任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容。

代码一：

```js
var a = 2
function foo(){
    var a = 3;
    console.log(a)
}
foo()
console.log(a)
//本例中：foo这个名称本身污染了所在作用域，其次，必须显式地通过函数名（foo()）调用这个函数才能运行其中的代码
//如果函数不需要函数名（或者至少函数名可以不污染所在作用域），并且能够自动运行，这将会更加理想。
```

JavaScript提供了能够同时解决这两个问题的方法

代码二：

```js
var a = 2
(function foo(){
    var a = 3;
    console.log(a)
})()//函数的自执行，实际上会被当作函数表达式而不是一个标准的函数声明来处理
//函数声明
function a(){}
//函数表达式
var f = function a(){}	//具名函数
var f = function () {}	//匿名函数
```

函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处。

上面代码一：foo被绑定再所在作用域(全局作用域)中，可以直接通过foo()来调用它

代码二：foo被绑定在函数表达式自身的函数中而不是所在作用域中。

### 3.3.1匿名和具名

```js
//函数表达式
var f = function a(){}	//具名函数
var f = function () {}	//匿名函数
```



对于函数表达式最熟悉的场景就是回调函数了

匿名函数缺点:

1. 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。
2. 如果没有函数名，当函数需要引用自身时只能使用已经过期的arguments.callee引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。
3. 匿名函数省略了对于代码可读性/可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。

### 3.3.2立即执行函数表达式

```js
var a = 2
(function foo(){
    var a = 3
    console.log(a)	//3
})();
console.log(a)	//2
```

由于函数被包含在一对()括号内部，因此成为了一个表达式，这种有一个专业术语叫IIFE，代表立即执行函数表达式

**IIFE的另一个非常普遍的进阶用法就是把它们当作函数调用并传递参数进去**

```js
var a = 2;
(function IIFE(global){
    var a = 3;
    console.log(a)
    console.log(global.a)
})(window)
```

## 3.4块作用域

尽管你可能连一行带有块作用域风格的代码都没有写过，但对下面这种很常见的JavaScript代码一定很熟悉：

```js
for(var i=0;i<10;i++){
    console.log(i)
}
console.log(i)//10；因为这个 i 被声明到了全局作用域里，
//在for循环的头部直接定义了变量i，通常是因为只想在for循环内部的上下文使用i，而忽略了i会被绑定在外部作用域(函数或全局)中的事实。
for(let j=0;j<10;j++){
    console.log(j)
}
console.log(j)//ReferenceError: j is not defined，因为在全局作用域中没有j这个变量，所以报错，可见用let声明的函数会只在for循环内部的上下文中使用，外部访问不到
```

### 3.4.1with

with关键字，用with从对象中创建出的作用域仅在with声明中而非外部作用域中有效。

### 3.4.2  try /catch

try/catch的catch分句会创建一个块作用域，其中声明的变量仅在catch内部有效。

例如:

```js
try {
    undefined()
}
catch(err){
    console.log(err)//可以正常输出；TypeError: undefined is not a function
}
console.log(err)//ReferenceError: err is not defined	引用错误：err未定义
```

### 3.4.3  let /const

ES6改变了现状，引入了新的let /const关键字，提供了除var以外的变量声明方式

let关键字可以将==变量绑定到所在的任意作用域中==（通常是=={ .. }==内部）。换句话说，let为其声明的变量隐式地劫持了所在的块作用域。

用let将变量附加在一个已经存在的块作用域上的行为是隐式的。

只要声明是有效的，在声明中的任意位置都可以使用{ .. }括号来为let创建一个用于绑定的块。

在第4章，会讨论提升，提升是指声明会被视为存在于其所出现的作用域的整个范围内。

但是使用let进行的声明不会在块作用域中进行提升。声明的代码被运行之前，声明并不“存在”。

**垃圾收集**

另一个块作用域非常有用的原因和闭包及回收内存垃圾的回收机制相关。

```js
for(let j=0;j<10;j++){
    console.log(j)
}
console.log(j)//ReferenceError: j is not defined
```

for循环头部的let不仅将i绑定到了for循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。

## 3.5小结

函数是JavaScript中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。

但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指{ .. }内部）。

从ES3开始，try/catch结构在catch分句中具有块作用域。

在ES6中引入了let关键字（var关键字的表亲），用来在任意代码块中声明变量。if (..) { let a =2; }会声明一个劫持了if的{ .. }块的变量，并且将变量添加到这个块中。

有些人认为块作用域不应该完全作为函数作用域的替代方案。两种功能应该同时存在，开发者可以并且也应该根据需要选择使用何种作用域，创造可读、可维护的优良代码。